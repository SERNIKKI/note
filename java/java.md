### 1、面向对象

* 面向过程更注重**事情的每一个步骤以及顺序**
* 面向对象更注重**事情有哪些参与者(对象)，以及各自需要做什么**

比如：洗衣机洗衣服
面向过程会将任务分为一系列步骤(函数)：1、打开洗衣机--->2、放衣服--->3、放洗衣粉--->4、清洗--->5、烘干
面向对象会拆出人和洗衣粉两个对象:
    * 人：打开洗衣机 放衣服 放洗衣粉
    * 洗衣机：清洗 烘干

>从以上例子看出，面向过程比较**直接高效**，而面向对象更**易于复用、扩展和维护**

>面向对象有三大特性：**封装**、**继承**、**多态**。

#### 封装
>封装的意义在于明确标识出允许外部使用的所有成员函数和数据项
>**内部细节对外部调用透明，外部调用无需修改或关心内部实现**

1.  javebean
JavaBean的属性**私有**，提供get和set访问，因为属性的赋值或者获取逻辑只能由**JavaBean本身决定**，而不能由**外部**胡乱修改
```java
    private String name;
    public void setName(String name){
        this.name = "get " + name;
    }
    这个name有着自己的命名规则，明显不能由外部直接修改
```
2.  orm框架
操作数据库，我们不需要关心链接是如何建立的，sql是怎么执行的，只需要引入`mybatis`，调用方法即可。

#### 继承
>继承基类的方法，并作出自己的改变和/或扩展
子类共性的方法或者属性直接使用**父类**的，而不需要自己定义，只需要**扩展自己个性化的**。

#### 多态
>基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
三个条件：继承、方法重写、父类引用指向子类对象
```java
父类类型 变量名 = new 子类对象;
变量名.方法名();
```
**无法调用子类特有功能**

### 2、JDK、JRE、JVM三者区别和联系

* JDK：java开发工具
* JRE Java运行时环境
* JVM jave虚拟机

![JDK.jpg](https://cdn.jsdelivr.net/gh/sernikki/MyMp3/java/jdk.png)

### 3、==与equals
>==对比的是**栈中的值**，基本数据类型对比的是**变量值**，引用类型是**堆中内存对象的地址**
>equals：object中默认也是采用==比较，通常会重写
Object：
```java
public boolean equals(Object obj){
    return (this == obj);
}
```
String：**实际上是比较内容**
```java
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

### 4、final
>含义为：最终的
* 修饰类：表示方法不可继承
* 修饰方法：表示方法不可被子类覆盖，但是可以重载
* 修饰变量：表示变量一旦被赋值就不可以更改它的值
    1.  修饰成员变量
    * 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。
    * 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。
    2.  修饰局部变量
    系统**不会**为局部变量进行**初始化**，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，既可以在定义时指定默认值(**后面的代码不能对变量再赋值**)，也可以不指定默认值，而在后面的代码中对final变量赋初值(**仅一次**)
    ```java
    public class FinalVar {
        final static int a = 0;//类变量在声明的时候需要赋值，或者在静态代码块中赋值
        /**
        static {
        a = 1;
        }*/
        final int b = 0;//成员变量在声明的时候就需要赋值，或者在代码块中赋值，或者在构造器中赋值
        /**
        {
            b = 0;
        }*/
        public static void main(String[] args) {
            final int localA;//局部变量只声明没有初始化不会报错
            localA = 0;//但是在使用之前必须赋值
            //localA = 1; 并且不允许第二次赋值
        }
    }
    ```
    3.  修饰基本数据类型和引用类型数据
    * 如果是基本数据类型的变量，则数值**在初始化之后就不能更改**。
    * 如果是引用类型变量，则在对其初始化之后便**不能让其再指向另一个对象**，**但是引用的值可以修改**。
    ```java
    public class Demo {
        public static void main(String[] args) {
            final int[] iArr= {1,2,3,4};
            iArr[1] = 3;//合法
            iArr = null;//不合法,不能重新赋值
            final User user= new User("12",12);
            user.setAge(13);//合法
            user = null;//非法
        }
    }
    ```
**为什么局部内部类和匿名内部类只能访问局部final变量？**
>编译之后会产生两个class文件。
```java
public class Test {
    public void test(final int b){
        final int a = 10;
        //匿名内部类
        new Thread(){
            public void run(){
                System.out.println(a);
                System.out.println(b);
            }
        }.start();
    }
}
class OutClass{
    final int age = 12;
    public void outPrint(final int x){
        class InClass{
            public void InPrint(){
                System.out.println(x);
                System.out.println(age);
            }
        }
        new InClass().InPrint();
    }
}
```
内部类和外部类是处于同一个级别的，内部类**不会**因为定义在方法中就会随着方法的执行完毕**就被销毁**。
这里会产生一个问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(**只有没有再引用它时，才会死亡**)。这里就会出现一个矛盾，内部类对象访问了一个**不存在的变量**。为了解决这个问题，**jvm**就将局部变量**复制**了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的“copy”。这样就好像延长了局部变量的生命周期。
将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也要跟着改变。解决这个问题的方法就是**将局部变量设为final**，对它初始化之后，不能再修改这个变量，就保证了内部类的成员变量和方法的变量的一致性。这实际上是一种妥协。

### 5、String、StringBuffer和StringBuilder的区别及使用环境

#### 区别

* String是**final**修饰的，不可变，每次操作都会**产生新的string对象**。
* StringBuffer和StringBuilder都是在**原对象**上操作。
* StringBuffer是线程安全的，StringBuilder是线程不安全的。
* StringBuffer的所有方法都是`synchronized`修饰的
**性能**：StringBuilder>StringBuffer>String

#### 场景
经常需要改变字符串内容时使用**StringBuffer**和**StringBuilder**，因为过多的产生新对象会消耗内存。
*优先使用StringBuilder，**多线程使用共享变量**时使用StringBuffer*。

### 6、重载和重写的区别

* **重载**:*发生在**同一个类中**，方法名**必须相同**，参数类型**不同**、个数**不同**、顺序**不同**、方法返回值和访问修饰符可以**不同**，发生在**编译时***。
* **重写**:*发生在**父子类中**，方法名、参数列表必须**相同**，返回值范围**小于等于**父类，抛出的异常范围**小于等于**父类，访问修饰符范围**大于等于**父类，如果父类中访问修饰符为`private`则子类**不能重写**该方法*。

### 7、接口和抽象类的区别

* 抽象类可以存在普通成员函数，而接口中只能存在`public abstract`方法。
* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是`public static final`类型的。
* 抽象类只能继承一个，接口可以实现多个。

接口的设计目的，是对类的行为进行**约束**(更准确的说是一种"**有**"约束，因为接口**不能规定类不可以有什么行为**)。也就是提供一种机制，可以强制要求**不同**的类具有**相同的行为**。它只约束了**行为的有无**，但不对如何实现行为进行限制。
而抽象类的设计目的，是**代码复用**，当不同的类具有某些相同的行为(几位行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生出一个抽象类。在这个抽象类中实现B，避免让所有的子类来实现B，这就达到了**代码复用**的目的。而`A-B`的部分，留给各个子类自己实现。正是因为`A-B`在这里没有实现，所以抽象类不允许被实例化出来(否则当调用`A-B`时，无法执行)
抽象类是**对类本质的抽象**，表达的是is a的关系，比如：`BWM is a Car`,抽象类包含并实现子类的通有特性，将子类存在差异化的特性进行抽象，交由子类去实现。
而接口是**对行为进行抽象**，表达的是like a的关系，比如：`Bird like a Aircraft`,但其实本质上是like a Bird。接口的核心是**定义行为**，即实现类可以做什么，至于实现类主体是谁、是如何实现的接口并不关心。

#### 使用场景
当你关注一个事物本质的时候，用抽象类；当关注一个操作的时候，用接口。

抽象类的功能要远高于接口，但是，定义抽象类的代价高，因为高级语言来所(从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且可以在一个类中同时实现多个接口。在设计上会降低难度。

### 8、List和Set的区别

* List：有序，按照对象进入的顺序保存对象、可重复、允许多个Null元素对象，可以使用iterator取出所有元素进行遍历，也可以用指定下标来获取元素。
* Set：无序、不可重复、最多允许一个Null元素对象，取元素时只能用iterator接口取得所有元素，再逐一遍历。

### 9、hashCode和equals

#### hashCode介绍
hashCode()的作用是获取**哈希码**，也称为**散列码**；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的**索引位置**。hashCode()定义在**JDK的Object.java**中，**Java中的任何实现类都包含有hashCode()函数**。散列表中存储的是键值对。

#### 为什么要有hashCode

**以"HashSet如何检查重复"为例来说明为什么要有hashCode**
对象加入HashSet时，HashSet会先计算出对象的hashCode值来判断对象加入的**位值**，看该位置**是否有值**，如果没有，HashSet会假设对象没有重复出现，但是如果发现有值，会调用equals()方法来检查两个对象是否真的相同，如果两者相同，HashSet就不会让其加入操作成功。如果不同，就会重新散列到其他的位值，这样就**大大减少了equal的次数**，相应的就提高了执行速度。

* 如果两个对象相等，则hashCode一定也是**相等**的。
* 两个对象相等，对两个对象调用equals方法都返回**true**
* 两个对象具有相同的hashCode值，它们**不一定相等**
* equals方法被覆盖过，则hashCode方法也必须被覆盖
* hashCode()的默认行为是**对堆上的对象产生独特值**。如果没有重写hashCode()，则该class中的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)