### 1、面向对象

* 面向过程更注重**事情的每一个步骤以及顺序**
* 面向对象更注重**事情有哪些参与者(对象)，以及各自需要做什么**

比如：洗衣机洗衣服
面向过程会将任务分为一系列步骤(函数)：1、打开洗衣机--->2、放衣服--->3、放洗衣粉--->4、清洗--->5、烘干
面向对象会拆出人和洗衣粉两个对象:
    * 人：打开洗衣机 放衣服 放洗衣粉
    * 洗衣机：清洗 烘干

>从以上例子看出，面向过程比较**直接高效**，而面向对象更**易于复用、扩展和维护**

>面向对象有三大特性：**封装**、**继承**、**多态**。

#### 封装
>封装的意义在于明确标识出允许外部使用的所有成员函数和数据项
>**内部细节对外部调用透明，外部调用无需修改或关心内部实现**

1.  javebean
JavaBean的属性**私有**，提供get和set访问，因为属性的赋值或者获取逻辑只能由**JavaBean本身决定**，而不能由**外部**胡乱修改
```java
    private String name;
    public void setName(String name){
        this.name = "get " + name;
    }
    这个name有着自己的命名规则，明显不能由外部直接修改
```
2.  orm框架
操作数据库，我们不需要关心链接是如何建立的，sql是怎么执行的，只需要引入`mybatis`，调用方法即可。

#### 继承
>继承基类的方法，并作出自己的改变和/或扩展
子类共性的方法或者属性直接使用**父类**的，而不需要自己定义，只需要**扩展自己个性化的**。

#### 多态
>基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不同。
三个条件：继承、方法重写、父类引用指向子类对象
```java
父类类型 变量名 = new 子类对象;
变量名.方法名();
```
**无法调用子类特有功能**

### 2、JDK、JRE、JVM三者区别和联系

* JDK：java开发工具
* JRE Java运行时环境
* JVM jave虚拟机

![JDK.jpg](https://cdn.jsdelivr.net/gh/sernikki/MyMp3/java/jdk.png)

### 3、==与equals
>==对比的是**栈中的值**，基本数据类型对比的是**变量值**，引用类型是**堆中内存对象的地址**
>equals：object中默认也是采用==比较，通常会重写
Object：
```java
public boolean equals(Object obj){
    return (this == obj);
}
```
String：**实际上是比较内容**
```java
public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof String) {
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) {
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) {
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                }
                return true;
            }
        }
        return false;
    }
```

### 4、final
>含义为：最终的
* 修饰类：表示方法不可继承
* 修饰方法：表示方法不可被子类覆盖，但是可以重载
* 修饰变量：表示变量一旦被赋值就不可以更改它的值
    1.  修饰成员变量
    * 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值。
    * 如果final修饰的是成员变量，可以在非静态初始化块、声明该变量或者构造器中执行初始值。
    2.  修饰局部变量
    系统**不会**为局部变量进行**初始化**，局部变量必须由程序员显示初始化。因此使用final修饰局部变量时，既可以在定义时指定默认值(**后面的代码不能对变量再赋值**)，也可以不指定默认值，而在后面的代码中对final变量赋初值(**仅一次**)
    ```java
    public class FinalVar {
        final static int a = 0;//类变量在声明的时候需要赋值，或者在静态代码块中赋值
        /**
        static {
        a = 1;
        }*/
        final int b = 0;//成员变量在声明的时候就需要赋值，或者在代码块中赋值，或者在构造器中赋值
        /**
        {
            b = 0;
        }*/
        public static void main(String[] args) {
            final int localA;//局部变量只声明没有初始化不会报错
            localA = 0;//但是在使用之前必须赋值
            //localA = 1; 并且不允许第二次赋值
        }
    }
    ```
    3.  修饰基本数据类型和引用类型数据
    * 如果是基本数据类型的变量，则数值**在初始化之后就不能更改**。
    * 如果是引用类型变量，则在对其初始化之后便**不能让其再指向另一个对象**，**但是引用的值可以修改**。
    ```java
    public class Demo {
        public static void main(String[] args) {
            final int[] iArr= {1,2,3,4};
            iArr[1] = 3;//合法
            iArr = null;//不合法,不能重新赋值
            final User user= new User("12",12);
            user.setAge(13);//合法
            user = null;//非法
        }
    }
    ```
**为什么局部内部类和匿名内部类只能访问局部final变量？**
>编译之后会产生两个class文件。
```java
public class Test {
    public void test(final int b){
        final int a = 10;
        //匿名内部类
        new Thread(){
            public void run(){
                System.out.println(a);
                System.out.println(b);
            }
        }.start();
    }
}
class OutClass{
    final int age = 12;
    public void outPrint(final int x){
        class InClass{
            public void InPrint(){
                System.out.println(x);
                System.out.println(age);
            }
        }
        new InClass().InPrint();
    }
}
```
内部类和外部类是处于同一个级别的，内部类**不会**因为定义在方法中就会随着方法的执行完毕**就被销毁**。
这里会产生一个问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(**只有没有再引用它时，才会死亡**)。这里就会出现一个矛盾，内部类对象访问了一个**不存在的变量**。为了解决这个问题，**jvm**就将局部变量**复制**了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的“copy”。这样就好像延长了局部变量的生命周期。
将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也要跟着改变。解决这个问题的方法就是**将局部变量设为final**，对它初始化之后，不能再修改这个变量，就保证了内部类的成员变量和方法的变量的一致性。这实际上是一种妥协。

### 5、String、StringBuffer和StringBuilder的区别及使用环境

#### 区别

* String是**final**修饰的，不可变，每次操作都会**产生新的string对象**。
* StringBuffer和StringBuilder都是在**原对象**上操作。
* StringBuffer是线程安全的，StringBuilder是线程不安全的。
* StringBuffer的所有方法都是`synchronized`修饰的
**性能**：StringBuilder>StringBuffer>String

#### 场景
经常需要改变字符串内容时使用**StringBuffer**和**StringBuilder**，因为过多的产生新对象会消耗内存。
*优先使用StringBuilder，**多线程使用共享变量**时使用StringBuffer*。

### 6、重载和重写的区别

* **重载**:*发生在**同一个类中**，方法名**必须相同**，参数类型**不同**、个数**不同**、顺序**不同**、方法返回值和访问修饰符可以**不同**，发生在**编译时***。
* **重写**:*发生在**父子类中**，方法名、参数列表必须**相同**，返回值范围**小于等于**父类，抛出的异常范围**小于等于**父类，访问修饰符范围**大于等于**父类，如果父类中访问修饰符为`private`则子类**不能重写**该方法*。

### 7、接口和抽象类的区别

* 抽象类可以存在普通成员函数，而接口中只能存在`public abstract`方法。
* 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是`public static final`类型的。
* 抽象类只能继承一个，接口可以实现多个。

接口的设计目的，是对类的行为进行**约束**(更准确的说是一种"**有**"约束，因为接口**不能规定类不可以有什么行为**)。也就是提供一种机制，可以强制要求**不同**的类具有**相同的行为**。它只约束了**行为的有无**，但不对如何实现行为进行限制。
而抽象类的设计目的，是**代码复用**，当不同的类具有某些相同的行为(几位行为集合A)，且其中一部分行为的实现方式一致时(A的非真子集，记为B)，可以让这些类都派生出一个抽象类。在这个抽象类中实现B，避免让所有的子类来实现B，这就达到了**代码复用**的目的。而`A-B`的部分，留给各个子类自己实现。正是因为`A-B`在这里没有实现，所以抽象类不允许被实例化出来(否则当调用`A-B`时，无法执行)
抽象类是**对类本质的抽象**，表达的是is a的关系，比如：`BWM is a Car`,抽象类包含并实现子类的通有特性，将子类存在差异化的特性进行抽象，交由子类去实现。
而接口是**对行为进行抽象**，表达的是like a的关系，比如：`Bird like a Aircraft`,但其实本质上是like a Bird。接口的核心是**定义行为**，即实现类可以做什么，至于实现类主体是谁、是如何实现的接口并不关心。

#### 使用场景
当你关注一个事物本质的时候，用抽象类；当关注一个操作的时候，用接口。

抽象类的功能要远高于接口，但是，定义抽象类的代价高，因为高级语言来所(从实际设计上来说也是)每个类只能继承一个类。在这个类中，你必须继承或编写所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且可以在一个类中同时实现多个接口。在设计上会降低难度。

### 8、List和Set的区别

* List：有序，按照对象进入的顺序保存对象、可重复、允许多个Null元素对象，可以使用iterator取出所有元素进行遍历，也可以用指定下标来获取元素。
* Set：无序、不可重复、最多允许一个Null元素对象，取元素时只能用iterator接口取得所有元素，再逐一遍历。

### 9、hashCode和equals

#### hashCode介绍
hashCode()的作用是获取**哈希码**，也称为**散列码**；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的**索引位置**。hashCode()定义在**JDK的Object.java**中，**Java中的任何实现类都包含有hashCode()函数**。散列表中存储的是键值对。

#### 为什么要有hashCode

**以"HashSet如何检查重复"为例来说明为什么要有hashCode**
对象加入HashSet时，HashSet会先计算出对象的hashCode值来判断对象加入的**位值**，看该位置**是否有值**，如果没有，HashSet会假设对象没有重复出现，但是如果发现有值，会调用equals()方法来检查两个对象是否真的相同，如果两者相同，HashSet就不会让其加入操作成功。如果不同，就会重新散列到其他的位值，这样就**大大减少了equal的次数**，相应的就提高了执行速度。

* 如果两个对象相等，则hashCode一定也是**相等**的。
* 两个对象相等，对两个对象调用equals方法都返回**true**
* 两个对象具有相同的hashCode值，它们**不一定相等**
* equals方法被覆盖过，则hashCode方法也必须被覆盖
* hashCode()的默认行为是**对堆上的对象产生独特值**。如果没有重写hashCode()，则该class中的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)

### 10、ArrayList和LinkedList

* ArrayList:基于**动态数组**，**连续内存存储**，适合做**下标访问(随机访问)**。扩容机制：因为数组的长度**固定**，超出长度存数据时会触发扩容机制，会重新**新建**一个数组，然后将老数组**拷贝**到新数组，如果不是尾部插入数据还会涉及到元素的**移动**(往后复制一份，插入新元素)。*使用尾插法并指定初始容量可以极大的提升性能，甚至超过LinkedList(需要创建大量的**node对象**)*
* LinkedList:基于**链表**，可以存储在**分散的内存**中，适合做**数据插入及删除**操作，不适合**查询**:需要逐一遍历。遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)获取某一元素时都需要对list**重新进行遍历**，性能消耗极大。也不能使用indexOf等返回索引，并利用其进行遍历，使用indexOf对list进行了遍历，当结果为空时还会遍历整个链表

### 11、HashMap和HashTable的区别和底层实现

#### 区别

* HashMap方法没有`synchronized`修饰，线程非安全，HashTable线程安全
* HashMap允许key和value为null，而HashTable不允许

#### 底层实现：数组+链表实现
>jdk8开始链表高度到**8**，数组长度超过**64**，链表转变为**红黑树**，元素以内部类Node节点存在

**插入过程**
* 计算key的hash值，**二次hash**然后对数组长度取模，对应到数组下标
* 如果没有产生hash冲突(下表位值没有元素)，则直接创建Node存入数组
* 如果产生Hash冲突，先进行**equals**比较，相同则**取代该元素**，不同，则判断链表高度**插入链表**，*链表高度达到8，并且数组长度达到64则1转变为红黑树，长度低于6则将红黑树转化为链表*。
* key为null时，存在下标**0**的位置

#### 数组扩容：和ArrayList的扩容机制一样

### 12、ConcurrentHashMap原理

* jdk7：
    1.  数据结构:`ReentrantLock+Segment+HashEntry`，一个`Segment`中包含一个`HashEntry`数组，每个`HashEntry`又是一个**链表**结构
    2.  元素查询:**二次**Hash，第一次Hash定位到**Segment**，第二次Hash定位到**元素所在的链表头部**
    3.  锁:`Segment`分段锁 `Segment`继承了`ReentrantLock`，锁定操作的`Segment`，其他的`Segment`不受影响，并发度为`Segment`的**个数**，可以通过构造函数指定，数组扩容不会影响其他的`Segment`
    4.  get方法无需加锁，**volatile保证**

* jdk8：
    1.  数据结构:`synchronized+CAS(乐观锁)+Node+红黑树`,Node的val和next都用volatile修饰，保证**可见性**。
    2.  元素查询:查找、替换、赋值操作都使用**CAS**。
    3.  锁:锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时会阻塞**所有的读写操作**、**并发扩容**。
    4.  读操作无锁:
        * Node的val和next使用volatile修饰，读写线程对变量互相可见
        * 数组用volatile修饰，保证扩容时被线程感知
    
### 13、如何实现一个IOC容器

1.  配置文件配置包扫描路径
2.  递归扫描获取.class文件
3.  反射、确定需要交给IOC管理的锁
4.  对需要注入的类进行依赖注入

    * 配置文件中指定需要扫描的包路径
    * 定义一些注解，分别别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注解
    * 从配置文件中获取需要扫描的包路径，获取当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储
    * 遍历这个set集合，获取在类上所有指定注解的类，并交给IOC容器，定义一个安全的Map存储这些对象
    * 遍历这个IOC容器，获取到每一个类的实例，判断里面是否有依赖其他类的实例，然后进行递归注入

### 14、什么是字节码，作用是什么

#### java中的编译器和解释器

java中引入了虚拟机的概念，即在机器和编译器程序之间加入了一层**抽象的虚拟**的机器。这台虚拟的机器在**任何平台**上都提供给编译器程序一个**共同的接口**。
编译程序只需要面向虚拟机。生成虚拟机能够理解的代码，然后由**解释器**来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种提供虚拟机理解的代码叫做**字节码**(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机。
*每一种平台的解释器是不同的，但是实现的虚拟是相同的*。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。这也就是解释了Java的编译与解释共存的特点。
>Java源代码-->编译器-->jvm可执行的Java字节码(即虚拟指令)-->jvm-->jvm中解释器-->机器可执行的二进制机器码-->程序运行

#### 采用字节码的好处

Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可以移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

### 15、Java类加载器

JDK自带有三个类加载器`bootstrap ClassLoader、ExtClassLoader、AppClassLoader`。
* `BootStrapClassLoader`是`ExtClassLoader`的**父类**加载器，默认加载`%JAVA_HOME%lib`下的jar包和class文件。
* `ExtClassLoader`是`AppClassLoader`的**父类**加载器，默认加载`%JAVA_HOME&/lib/ext`文件夹下的jar包和class文件。
* `AppClassLoader`是**自定义**类加载器的父类，负责加载classpath下的类文件。除了是系统类加载器之外，它还是**线程上下文加载器**。

>可以通过继承ClassLoader实现自定义类加载器

### 16、双亲委托模型

![双亲委托模型](https://cdn.jsdelivr.net/gh/sernikki/MyMp3/java/classLoader.png)

双亲委派的好处：
    * 主要是为了**安全性**，避免用户自己编写的类动态语言替换Java的一些核心类，比如String。
    * 同时也避免了**类的重复加载**，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是**不同**的两个类。

### 17、Java中的异常体系

![Java异常体系](https://cdn.jsdelivr.net/gh/sernikki/MyMp3/java/throwable.png)
Java中的所有异常都来自**顶级父类Throwable**。
Throwable下有两个子类Exception和Error。
Error是程序无法处理的错误，一旦出现这个错误，则程序被迫停止运行。
Exception不会导致程序停止，又分为两个部分RunTimeException(运行时异常)和CheckedException(检查异常)。
RunTimeException常常发生在程序运行过程中，会导致当前线程执行失败。CheckedException常常发生在程序编译过程中，会导致程序编译不通过。
>所有的这些异常又分为受查异常和非受查异常

* 非受查异常:Error、RunTimeException及其子类属于非受查异常，不强制用户进行异常处理
* 受查异常:除了非受查异常之外的都是受查异常，会强制用户进行异常处理

### 18、GC如何判断对象可以被回收

* 引用计数法：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收(在python、go等语言中使用)
* 可达性分析法：从**GC Roots**开始向下搜索，搜索所走过的路径称为**引用链**。当一个对象到**GC Root**没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就会判断为可回收对象。
>引用计数法，可能会出现A调用了B，而B又调用了A的情况，这个时候就算他们都不再使用了，但因为相互引用导致计数器为1，永远无法被回收

**GC Root**的对象有：
* 虚拟机栈(栈帧中的本地变量)中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI(即一般说的Native方法)引用的对象

可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会。对象被系统宣告死亡至少要经历两次标记过程:第一次是经过可达性分析发现没有与`GC Roots`相连的引用链，第二次在由虚拟机自动建立的`Finalizer`队列中判断是否需要执行`finalize`方法。
当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了`finalize`方法，若未覆盖，则直接将其回收。否则，若对象未执行过`finalize`方法，将其放入**F-Queue**队列，由一低优先级线程执行该队列中对象的`finalize`方法。执行`finalize`方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象"复活"。
**每个对象只能触发一次`finalize`方法**
由于`finalize`方法运行代价太高，不确定性大，无法保证各个对象的调用顺序，因此**不建议使用**

### 19、线程的生命周期及状态

1.  线程通常有五种状态:创建、就绪、运行、阻塞和死亡状态
2.  阻塞的情况又分为3种：
    1.  等待阻塞:运行的线程执行**wait**方法，该线程会释放占有的**所有资源**，JVM会把该线程放入**等待池**中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用`notify`或者`notifyAll`方法才能唤醒，**wait是`object`类的方法**。
    2.  同步阻塞:运行的线程在获取对象的**同步锁**时，若该同步锁被别的线程占用，则JVM会把该线程放入**锁池**中
    3.  其他阻塞:运行的线程执行`sleep`或`join`方法时，或者发出了`I/O请求`时，JVM会把该线程置为阻塞状态。当`sleep`状态超时、`join`等待线程终止或者`I/O处理`完毕时，线程重新转入**就绪状态**，**sleep是`Thread`类的方法**

#### 线程的五种状态

* 新建状态(New):新建了一个线程对象
* 就绪状态(Runnable):线程对象创建后，其他线程调用了该对象的start方法，该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
* 运行状态(Running):就绪的线程获取了CPU，执行程序代码
* 阻塞状态(Blocked):阻塞状态是因为某种原因放弃CPU使用权，暂时停止运行，直到线程进入就绪状态，才有机会转到运行状态。
* 死亡状态(Dead):线程执行完了或者因为异常退出了run方法，该线程结束生命周期。

### 20、sleep、wait、join、yield的区别

1.  锁池
所有需要竞争**同步锁**的线程都会放在锁池中，比如当前对象的锁已经被其中一个线程得到，则其他线程需要在这个锁池中进行等待，当前面的线程释放同步锁后，锁池中的线程去竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配
2.  等待锁
当我们调用**wait**方法后，线程会被放到等待池中，等待池的线程不会去竞争同步锁，只有调用了`notify()`或`notifyAll()`后等待池的线程才会去开始竞争锁，`notify`是随机从等待池中选出一个线程放到**锁池**，`notifyAll`是将等待池中的所有线程释放到**锁池**中

#### sleep和wait的区别

* **sleep是Thread类的静态本地方法，wait是Object类的方法**
* **sleep方法不会释放lock，但是wait方法会，而且会加入到等待队列中**
    >**sleep**就是把**cpu**的执行资格和执行权释放出去，不再运行此线程。当定时时间结束再取回**cpu**资源。参与**cpu**的调度，获取到**cpu**资源后就可以继续运行了，而如果**sleep**时该线程有锁，那么**sleep**不会释放这个锁，而是把锁带着进入了**冻结状态**，也就是说其他需要这个锁的线程根本不可能获取到这个锁，也就无法执行程序。如果在睡眠期间其他程序调用了这个线程的`interrupt`方法，那么这个线程就会抛出`interruptException`异常返回，**这点和wait是一样的**
* **sleep方法不依赖于同步器`synchronized`，但是wait需要依赖`synchronized`关键字**
* **sleep不需要被唤醒(休眠之后退出阻塞)，但是wait需要(不指定时间需要被别人中断)**
* **sleep一般用于当前线程休眠，或者轮循暂停操作，wait则多用于多线程之间的通信**
* **sleep会让出CPU执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会重新竞争到锁继续执行的**

`yield()`执行后线程直接进入就绪状态，马上释放cpu的执行权，但是依然保留了cpu的执行资格，所以有可能cpu下次进行线程通信调度还会让这个线程获取到执行权继续执行。
`join()`执行后线程进入阻塞状态，例如在线程B中调用线程A的`join()`，那么线程B就会进入到**阻塞队列**，直到线程A**结束或中断线程**
```java
public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("t1");
            }
        });
        t1.start();
        t1.join();
        //这段代码需要t1执行完后才会执行
        System.out.println("main");
    }
```